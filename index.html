<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Subnetter — IPv4 Subnetting Practice (VLSM)</title>

<style>
:root{
  --bg:#0b0f17;
  --bg2:#070a10;
  --muted:#94a3b8;
  --text:#e5e7eb;
  --line:rgba(148,163,184,.18);
  --accent:#60a5fa;
  --good:#34d399;
  --bad:#fb7185;
}
*{ box-sizing:border-box; }
body{
  margin:0;
  background:linear-gradient(180deg, var(--bg), var(--bg2));
  color:var(--text);
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
}
.container{
  max-width: 980px;
  margin: 28px auto;
  padding: 0 16px 56px;
}
h1{ margin:0; font-size:26px; letter-spacing:.2px; }
.sub{ color:var(--muted); font-size:14px; margin-top:6px; }

.toolbar{
  display:flex;
  gap:12px;
  flex-wrap:wrap;
  margin-top:16px;
}
label{ font-size:13px; color:var(--muted); display:block; margin-bottom:6px; }
select, input, button{
  width:100%;
  padding:10px 12px;
  border-radius:12px;
  border:1px solid var(--line);
  background:rgba(17,24,39,.75);
  color:var(--text);
  outline:none;
}
select:focus, input:focus{
  border-color: rgba(96,165,250,.65);
  box-shadow: 0 0 0 3px rgba(96,165,250,.14);
}
button{
  cursor:pointer;
  border-color: rgba(96,165,250,.35);
}
button.primary{
  background: linear-gradient(180deg, rgba(96,165,250,.28), rgba(96,165,250,.12));
}
.card{
  margin-top:16px;
  background:rgba(17,24,39,.6);
  border:1px solid var(--line);
  border-radius:16px;
  padding:14px;
}
.small{ font-size:13px; color:var(--muted); }
code{
  background:rgba(148,163,184,.12);
  padding:2px 8px;
  border-radius:10px;
  border:1px solid rgba(148,163,184,.14);
}
.subnet{
  margin-top:14px;
  border:1px solid var(--line);
  border-radius:14px;
  padding:14px;
  background:rgba(17,24,39,.48);
}
.subnetHeader{
  display:flex;
  justify-content:space-between;
  align-items:baseline;
  gap:12px;
  flex-wrap:wrap;
  margin-bottom:8px;
}
.status{
  font-size:13px;
  padding:4px 10px;
  border-radius:999px;
  border:1px solid var(--line);
  background:rgba(17,24,39,.55);
  color:var(--muted);
}
.status.good{ color:var(--good); border-color: rgba(52,211,153,.35); }
.status.bad{ color:var(--bad); border-color: rgba(251,113,133,.35); }

.grid{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:10px;
}
@media(max-width:820px){
  .grid{ grid-template-columns:1fr; }
}

details{
  margin-top:12px;
  border:1px solid var(--line);
  border-radius:14px;
  padding:10px 12px;
  background:rgba(17,24,39,.48);
}
summary{
  cursor:pointer;
  color:var(--text);
  font-weight:600;
}
pre{
  white-space:pre-wrap;
  word-break:break-word;
  color:var(--text);
  margin:10px 0 0;
  font-size:13px;
  line-height:1.35;
}
a{ color:var(--accent); text-decoration:none; }
a:hover{ text-decoration:underline; }
</style>
</head>

<body>
<div class="container">

  <h1>Subnetter</h1>
  <div class="sub">Practice IPv4 subnetting & VLSM. Fill in Mask, CIDR, Network ID, Broadcast, First usable (Gateway), Last usable.</div>

  <div class="toolbar">
    <div style="flex:1 1 240px;">
      <label for="difficulty">Difficulty</label>
      <select id="difficulty">
        <option value="easy">Easy (1 subnet)</option>
        <option value="medium">Medium (equal-size)</option>
        <option value="hard">Hard (VLSM)</option>
      </select>
    </div>
    <div style="flex:1 1 200px;">
      <label>&nbsp;</label>
      <button class="primary" id="newBtn">New Question</button>
    </div>
    <div style="flex:1 1 200px;">
      <label>&nbsp;</label>
      <button id="checkBtn">Check Answers</button>
    </div>
  </div>

  <div id="question" class="card" style="display:none;"></div>
  <div id="inputs"></div>
  <div id="result" class="card" style="display:none;"></div>

</div>

<script>
/* ---------------- IPv4 helpers ---------------- */
const ipToInt = ip => ip.split('.').reduce((a,o)=>(a<<8)+(+o),0)>>>0;
const intToIp = n => [n>>>24,n>>>16&255,n>>>8&255,n&255].join('.');
const maskFromPrefix = p => p===0?0:(0xffffffff<<(32-p))>>>0;

function normalizeIp(v){
  try { return intToIp(ipToInt(v.trim())); } catch { return null; }
}
function normalizeCidr(v){
  if (!v) return null;
  const t = v.trim();
  if (!t) return null;
  return t.startsWith("/") ? t : "/" + t;
}

function subnetInfo(net,p){
  const size = 2**(32-p);
  return {
    prefix:p,
    mask:intToIp(maskFromPrefix(p)),
    network:intToIp(net),
    broadcast:intToIp((net + size - 1) >>> 0),
    gateway:intToIp((net + 1) >>> 0),
    last:intToIp((net + size - 2) >>> 0),
    blockSize:size
  };
}
function hostsToPrefix(h){
  return 32 - Math.ceil(Math.log2(h + 2));
}
function randInt(min, maxIncl){
  return Math.floor(Math.random() * (maxIncl - min + 1)) + min;
}

/* ---------------- Random assigned block (private ranges) ----------------
   Private pools:
   - 10.0.0.0/8
   - 172.16.0.0/12
   - 192.168.0.0/16
*/
const POOLS = [
  { name:"10/8",      net: ipToInt("10.0.0.0"),      prefix: 8 },
  { name:"172.16/12", net: ipToInt("172.16.0.0"),   prefix: 12 },
  { name:"192.168/16",net: ipToInt("192.168.0.0"),  prefix: 16 },
];

function randomBlockInSupernet(superNet, superPrefix, targetPrefix){
  // choose a random aligned targetPrefix network within the supernet
  const superSize = 2**(32-superPrefix);
  const targetSize = 2**(32-targetPrefix);
  const blocks = superSize / targetSize;
  const idx = randInt(0, blocks - 1);
  return ((superNet + (idx * targetSize)) >>> 0);
}

function pickPoolForPrefix(targetPrefix){
  // Pools that can contain the requested prefix.
  // /8: only 10/8 realistically
  if (targetPrefix === 8) return [POOLS[0]];
  // /16 can be from 10/8, 172.16/12, 192.168/16
  if (targetPrefix === 16) return [POOLS[0], POOLS[1], POOLS[2]];
  // /24 can be from 10/8, 172.16/12, 192.168/16
  if (targetPrefix === 24) return [POOLS[0], POOLS[1], POOLS[2]];
  // fallback
  return [POOLS[0], POOLS[1], POOLS[2]];
}

function randomAssignedBlockByPrefix(targetPrefix){
  const pools = pickPoolForPrefix(targetPrefix);
  const pool = pools[randInt(0, pools.length - 1)];

  // If the pool prefix equals targetPrefix, only one block exists (e.g., 192.168.0.0/16)
  const net = (pool.prefix === targetPrefix)
    ? pool.net
    : randomBlockInSupernet(pool.net, pool.prefix, targetPrefix);

  return { net, prefix: targetPrefix };
}

/* ---------------- Difficulty-based assigned prefix ---------------- */
function pickAssignedPrefix(diff){
  if (diff === "medium"){
    // 60% /24, 30% /16, 10% /8 (as requested)
    const r = Math.random();
    if (r < 0.60) return 24;
    if (r < 0.90) return 16;
    return 8;
  }
  // easy/hard: simple uniform among /24 /16 /8
  const opts = [24,16,8];
  return opts[randInt(0, opts.length-1)];
}

/* ---------------- Requirements ---------------- */
function genHostsEasy(basePrefix){
  const maxByBase = basePrefix >= 24 ? 200 : basePrefix >= 16 ? 2000 : 8000;
  return [randInt(10, Math.min(400, maxByBase))];
}

function genHostsHard(basePrefix, count){
  const maxByBase = basePrefix >= 24 ? 200 : basePrefix >= 16 ? 2000 : 8000;
  const reqs = [];
  for (let i=0;i<count;i++){
    const roll = Math.random();
    let h;
    if (roll < 0.45) h = randInt(2, 60);
    else if (roll < 0.85) h = randInt(61, Math.min(300, maxByBase));
    else h = randInt(301, maxByBase);
    reqs.push(h);
  }
  return reqs;
}

function genHostsMedium(basePrefix, count){
  // equal-size, but not ridiculous: keep it sane even if assigned block is /8
  const MEDIUM_MAX_HOSTS = 4094; // ~ /20 usable cap
  const baseBlock = 2**(32-basePrefix);

  // minimum subnet size to create at least `count` subnets inside base
  const minSubnetPrefix = Math.min(30, basePrefix + Math.ceil(Math.log2(count)));

  // don’t allow massive /9 /10 style medium subnets; force more granular blocks
  const subnetPrefix = Math.max(minSubnetPrefix, 20); // /20 or more specific
  const usable = (2**(32-subnetPrefix)) - 2;

  const cap = Math.min(usable, MEDIUM_MAX_HOSTS);
  const floor = Math.max(30, Math.floor(cap * 0.35));
  const ceil  = Math.max(floor, Math.floor(cap * 0.75));
  const h = randInt(floor, ceil);

  return Array(count).fill(h);
}

/* ---------------- Fit check (block-size math) ---------------- */
function totalAllocatedFromHosts(hostReqs){
  const prefixes = hostReqs.map(hostsToPrefix);
  const total = prefixes.reduce((sum,p)=> sum + (2**(32-p)), 0);
  return { prefixes, total };
}

function buildAllocations(base, prefixes){
  let cursor = base.net;
  const allocs = [];
  for (const p of prefixes){
    const size = 2**(32-p);
    cursor = Math.ceil(cursor/size)*size;
    allocs.push(subnetInfo(cursor,p));
    cursor = (cursor + size) >>> 0;
  }
  return allocs;
}

/* ---------------- AI link (Google udm=50&aep=11) ---------------- */
function buildAiLink(base, hosts){
  const q =
`show a detailed step-by-step walkthrough explaining how to subnet ${intToIp(base.net)}/${base.prefix}
into ${hosts.length} subnets with host requirements ${hosts.join(", ")}.
Include how to determine subnet sizes, CIDR prefixes, network IDs, broadcast addresses, and usable host ranges.`;

  return `https://www.google.com/search?udm=50&aep=11&q=${encodeURIComponent(q)}`;
}

/* ---------------- UI + logic ---------------- */
const els = {
  difficulty: document.getElementById("difficulty"),
  newBtn: document.getElementById("newBtn"),
  checkBtn: document.getElementById("checkBtn"),
  question: document.getElementById("question"),
  inputs: document.getElementById("inputs"),
  result: document.getElementById("result"),
};

let current = [];
let expectedHosts = [];
let currentBase = null;

function renderQuestion(diff){
  els.question.style.display = "";
  const reminder = diff === "hard"
    ? `<div class="small" style="margin-top:8px;"><i>In VLSM, allocate address space from the largest requirement downward to minimize fragmentation.</i></div>`
    : "";

  els.question.innerHTML = `
    <b>Assigned block:</b> <code>${intToIp(currentBase.net)}/${currentBase.prefix}</code>
    <div class="small" style="margin-top:6px;">Requirements (largest first):</div>
    <ul style="margin:10px 0 0 18px;">
      ${expectedHosts.map((h,i)=>`<li><b>Subnet ${i+1}</b>: ${h} hosts</li>`).join("")}
    </ul>
    ${reminder}
  `;
}

function renderInputs(){
  els.inputs.innerHTML = current.map((_,i)=>`
    <div class="subnet">
      <div class="subnetHeader">
        <div><b>Subnet ${i+1}</b> <span class="small">(${expectedHosts[i]} hosts)</span></div>
        <div class="status" id="s${i}">—</div>
      </div>

      <div class="grid">
        <div>
          <label>Mask</label>
          <input data-i="${i}" data-f="mask">
        </div>
        <div>
          <label>CIDR</label>
          <input data-i="${i}" data-f="cidr">
        </div>
        <div>
          <label>Network ID</label>
          <input data-i="${i}" data-f="network">
        </div>
        <div>
          <label>Broadcast</label>
          <input data-i="${i}" data-f="broadcast">
        </div>
        <div>
          <label>First usable (Gateway)</label>
          <input data-i="${i}" data-f="gateway">
        </div>
        <div>
          <label>Last usable</label>
          <input data-i="${i}" data-f="last">
        </div>
      </div>
    </div>
  `).join("");
}

function collectRow(i){
  const box = els.inputs.querySelectorAll(".subnet")[i];
  const inputs = [...box.querySelectorAll("input[data-f]")];
  const obj = {};
  for (const inp of inputs) obj[inp.dataset.f] = inp.value;
  return obj;
}

function newQuestion(){
  els.result.style.display = "none";
  els.result.innerHTML = "";

  const diff = els.difficulty.value;
  const assignedPrefix = pickAssignedPrefix(diff);
  currentBase = randomAssignedBlockByPrefix(assignedPrefix);

  const count =
    diff === "easy" ? 1 :
    randInt(2,5);

  // generate requirements
  let hostReqs =
    diff === "easy" ? genHostsEasy(currentBase.prefix) :
    diff === "medium" ? genHostsMedium(currentBase.prefix, count) :
    genHostsHard(currentBase.prefix, count);

  // option A: largest -> smallest for display + matching
  hostReqs.sort((a,b)=>b-a);

  // ensure the blocks fit; regenerate if not
  const baseBlock = 2**(32-currentBase.prefix);
  for (let tries=0; tries<250; tries++){
    const calc = totalAllocatedFromHosts(hostReqs);
    if (calc.total <= baseBlock){
      expectedHosts = hostReqs;
      current = buildAllocations(currentBase, calc.prefixes);
      renderQuestion(diff);
      renderInputs();
      return;
    }

    hostReqs =
      diff === "easy" ? genHostsEasy(currentBase.prefix) :
      diff === "medium" ? genHostsMedium(currentBase.prefix, count) :
      genHostsHard(currentBase.prefix, count);

    hostReqs.sort((a,b)=>b-a);
  }

  // fallback (should never hit)
  expectedHosts = [50,20].slice(0,count);
  const calc = totalAllocatedFromHosts(expectedHosts);
  current = buildAllocations(currentBase, calc.prefixes);
  renderQuestion(diff);
  renderInputs();
}

function checkAnswers(){
  let okAll = true;
  const explain = [];

  for (let i=0;i<current.length;i++){
    const c = current[i];
    const u = collectRow(i);

    const good =
      (u.mask || "").trim() === c.mask &&
      normalizeCidr(u.cidr) === `/${c.prefix}` &&
      normalizeIp(u.network) === c.network &&
      normalizeIp(u.broadcast) === c.broadcast &&
      normalizeIp(u.gateway) === c.gateway &&
      normalizeIp(u.last) === c.last;

    const status = document.getElementById("s"+i);
    if (good){
      status.textContent = "✔ Correct";
      status.className = "status good";
    } else {
      okAll = false;
      status.textContent = "✖ Incorrect";
      status.className = "status bad";

      explain.push(
`Subnet ${i+1} (${expectedHosts[i]} hosts)

Correct values:
  Mask: ${c.mask}
  CIDR: /${c.prefix}
  Network ID: ${c.network}
  Broadcast: ${c.broadcast}
  First usable (Gateway): ${c.gateway}
  Last usable: ${c.last}

Solve method:
  1) Choose smallest prefix that supports ${expectedHosts[i]} hosts.
  2) Allocate largest requirements first (VLSM).
  3) Block size here is ${c.blockSize} addresses; next subnet starts after the block.
`);
    }
  }

  els.result.style.display = "";
  if (okAll){
    els.result.innerHTML = `<b style="color:var(--good)">All subnets correct.</b>`;
  } else {
    const link = buildAiLink(currentBase, expectedHosts);
    els.result.innerHTML = `
      <details open>
        <summary>Show correct answers & explanations</summary>
        <pre>${explain.join("\n\n")}</pre>
        <div style="margin-top:10px;">
          <a href="${link}" target="_blank">Ask AI to explain how to solve this (detailed walkthrough)</a>
        </div>
      </details>
    `;
  }
}

/* ---------------- Wire up ---------------- */
els.newBtn.addEventListener("click", newQuestion);
els.checkBtn.addEventListener("click", checkAnswers);

newQuestion();
</script>
<script data-goatcounter="https://concsp.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
<footer style="
  margin-top:40px;
  padding-top:16px;
  border-top:1px solid rgba(148,163,184,.18);
  text-align:center;
  font-size:13px;
  color:#94a3b8;">
  Built by Cameron ·
  <a href="https://github.com/concsp" target="_blank">GitHub</a>
</footer>        
</body>
</html>
